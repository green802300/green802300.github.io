<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-08-29T16:25:30+08:00</updated><id>http://localhost:4000/</id><title type="html">Green’s HomePage</title><subtitle>这是一个初学博客的博主</subtitle><author><name>true</name></author><entry><title type="html">3 机器人导航 global_planner</title><link href="http://localhost:4000/2019/08/29/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%B9%8Bglobal_planner.html" rel="alternate" type="text/html" title="3 机器人导航 global_planner" /><published>2019-08-29T00:00:00+08:00</published><updated>2019-08-29T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/29/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%B9%8Bglobal_planner</id><content type="html" xml:base="http://localhost:4000/2019/08/29/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%B9%8Bglobal_planner.html">&lt;h1 id=&quot;global-planner&quot;&gt;global planner&lt;/h1&gt;

&lt;p&gt;  在对move_base中的全局规划进行介绍之前，我们先来回顾一下Navigation的框架，可以看出位于红框中的global_planner是move_base节点的一部分，输入是目标位置以及global_costmap的信息，输出是全局的规划路径，作为local_planner的输入。&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;框架.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;  在ROS的导航中，首先会通过全局路径规划，计算出机器人到目标位置的全局路线。全局路径规划一般是由navfn或global_planner插件实现的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;navfn&lt;/strong&gt;
通过Dijkstra最优路径的算法，计算costmap上的最小花费路径，作为机器人的全局路线。在算法上还有A*算法。&lt;/li&gt;
&lt;/ul&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;navfn.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;global_planner&lt;/strong&gt;
根据给定的目标位置进行总体路径的规划；这个package为导航提供了一种快速，内插值的全局规划器， 继承了nav_core包中nav_core::BaseGlobalPlanner接口，该实现相比navfn使用更加灵活。&lt;/li&gt;
&lt;/ul&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;g_b.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;路径规划算法&quot;&gt;路径规划算法&lt;/h2&gt;

&lt;p&gt;  路径规划是指的是机器人的最优路径规划问题，即依据某个或某些优化准则（如工作代价最小、行走路径最短、行走时间最短等），在工作空间中找到一个从起始位置到目标位置能避开障碍物的最优路径。&lt;/p&gt;

&lt;p&gt;  路径规划的方法主要可以分为以下五类，global_planner主要用到的就是第二类基于节点的方法。&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;路径规划算法概况.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;dijkstra算法&quot;&gt;Dijkstra算法&lt;/h3&gt;

&lt;p&gt;  迪杰斯特拉（Dijkstra）算法是典型的用来解决最短路径的算法，也是很多教程中的范例，由荷兰计算机科学家狄克斯特拉于1959年提出，用来求得从起始点到其他所有点最短路径。该算法采用了贪心的思想。&lt;/p&gt;

&lt;p&gt;  下面结合实例来看一下。&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d1.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s是start顶点，t是terminal顶点，要求出s到t的最短路径。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d2.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;首先我们初始化了两个集合，S集合是已计算出最短路径的顶点集合，PQ是未计算出最短路径的顶点的集合。
顶点附近的绿色数字表示从源节点到当前节点的距离，若二者没有直接相连，则为无穷大（∞）。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d3.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;从PQ的所有顶点中，选择距离值最小的顶点放入集合S中。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d4.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;首先将起始点s放入集合S中，然后将距离进行更新，可见图中2、6、7顶点的距离值发生了变化。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d5.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;此时PQ集合中距离值最小的顶点是2号顶点。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d6.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;此时将2号顶点放入集合S中，同时记录其父顶点为S。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d7.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;然后将距离值进行更新。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d8.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;此时PQ中6号顶点距离值最小。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d9.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;将6号顶点加入集合S，同时，PQ中的5号和3号顶点距离值进行了更新。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d10.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;此时，PQ中7号顶点的距离值最小。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d11.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;7号顶点加入集合S，同时5号和t顶点距离值更新。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d12.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;此时，PQ中3号顶点的距离值最小。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d13.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3号顶点加入集合S，同时5号和t顶点距离值更新。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d14.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;此时，PQ中5号顶点的距离值最小。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d15.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5号顶点加入集合S，同时4号和t顶点距离值更新。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d16.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;此时，PQ中4号顶点的距离值最小。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d17.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4号顶点加入集合S，此时t的距离值由于未减小，因此没有发生变化。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d18.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;此时仅剩最后一个t顶点。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d19.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;t顶点加入集合S。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;d20.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;实际上，我们可以得到起始点s到各个顶点的最短距离：2(9),3(32),4(45),5(34),6(14),7(15),t(50) 。
从起始点s到目标点t的最短路径为s-&amp;gt;6-&amp;gt;3-&amp;gt;5-&amp;gt;t。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  总结一下&lt;strong&gt;算法流程&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;初始化时，S只含有源节点s；&lt;/li&gt;
  &lt;li&gt;从PQ中选取一个距离s最小的顶点k加入S中（该选定的距离就是s到k的最短路径长度）；&lt;/li&gt;
  &lt;li&gt;以k为新考虑的中间点，修改PQ中各顶点的距离；若从源节点s到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值是顶点k的距离加上k到u的距离；&lt;/li&gt;
  &lt;li&gt;重复步骤2和3，直到所有顶点都包含在S中。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;a算法&quot;&gt;A*算法&lt;/h3&gt;

&lt;p&gt;  同样地，我们结合实例来看一下A*算法是如何实现的。&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;a1.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;绿色方格是我们的起始点，红色方格是我们的目标点，蓝色表示障碍物，我们需要寻找起始点到目标点的
路径。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;a2.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;首先，将图中的搜索区域用二维数组表示，数组的每一项代表一个格子，它的状态分为可走 (walkalbe) 
和不可走 (unwalkable) 。

我们还需要初始化Open List和Close List，Open List用于存放路径规划过程中待检测的格子，而
Close List用于存放已检测过的格子。我们先将起始点A(1,2)放入Closed List，然后把相邻的可走的 
方格加入到 Open List 中，然后把起点 A 设置为这些方格的父节点，方便路径追踪。

我们引入一个计算公式：F = G + H。其中G代表的是从起始节点沿着已生成的路径到指定待检测格子的
移动开销。H指待测格子到目标节点的估计移动开销，也称为启发项。假设横向或纵向移动的开销G是10，
沿对角线移动的开销是14，H是当前方格到目标方格的横向或纵向移动开销之和。

因为Open List中方格(2,2)的F值最小，因此将(2,2)加入Closed List并作为当前要处理的节点。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;a3.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(2,2)的8个相邻方格中，有3个是障碍物，1个是在Close List中，忽略这几个方格。

剩下的4个方格都是在Open List中的方格，因此检查经由(2,2)到这4个方格的路径是否更好，用G来衡量，
比如原来从(1,2)到(2,3)的G为14，若从(1,2)先经过(2,2)再到(2,3)，则G变为20，显然还不如原来的路
径，对于其它3个方格亦是如此。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;a4.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;将(2,1)加入Close List，其相邻的8个方格中，2个障碍物的方格和障碍物下的方格(3,0)认为不可达，
(1,2)和(2,2)在Close List中不做处理，Open List中的(1,1)没有优化原来的路径。

(1,0)和(2,0)加入Open List，并将父节点设置为(2,1)，分别计算F、G、H值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;a5.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;以此类推，直到目标方格B加入Open List。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;a6.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;从目标方格B开始沿着父节点移动到起始方格A，就是求得的路径：
(5,2)-&amp;gt;(5,1)-&amp;gt;(4,0)-&amp;gt;(3,0)-&amp;gt;(2,0)-&amp;gt;(2,1)-&amp;gt;(1,2)。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;对比&quot;&gt;对比&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Dijkstra 算法&lt;/strong&gt;需要载入全部数据进行全局遍历，确保运算结果一定是最短路径。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;A*算法&lt;/strong&gt;的核心思想在于设置的代价函数F=H+G，来寻找距离start和goal代价距离和F最少的点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] https://blog.csdn.net/heroacool/article/details/51014824&lt;/p&gt;

&lt;p&gt;[2] https://blog.csdn.net/weixin_44489823/article/details/89382502&lt;/p&gt;</content><author><name>Green</name></author><category term="navigation" /><summary type="html">global planner   在对move_base中的全局规划进行介绍之前，我们先来回顾一下Navigation的框架，可以看出位于红框中的global_planner是move_base节点的一部分，输入是目标位置以及global_costmap的信息，输出是全局的规划路径，作为local_planner的输入。   在ROS的导航中，首先会通过全局路径规划，计算出机器人到目标位置的全局路线。全局路径规划一般是由navfn或global_planner插件实现的。 navfn 通过Dijkstra最优路径的算法，计算costmap上的最小花费路径，作为机器人的全局路线。在算法上还有A*算法。 global_planner 根据给定的目标位置进行总体路径的规划；这个package为导航提供了一种快速，内插值的全局规划器， 继承了nav_core包中nav_core::BaseGlobalPlanner接口，该实现相比navfn使用更加灵活。 路径规划算法   路径规划是指的是机器人的最优路径规划问题，即依据某个或某些优化准则（如工作代价最小、行走路径最短、行走时间最短等），在工作空间中找到一个从起始位置到目标位置能避开障碍物的最优路径。   路径规划的方法主要可以分为以下五类，global_planner主要用到的就是第二类基于节点的方法。 Dijkstra算法   迪杰斯特拉（Dijkstra）算法是典型的用来解决最短路径的算法，也是很多教程中的范例，由荷兰计算机科学家狄克斯特拉于1959年提出，用来求得从起始点到其他所有点最短路径。该算法采用了贪心的思想。   下面结合实例来看一下。 s是start顶点，t是terminal顶点，要求出s到t的最短路径。 首先我们初始化了两个集合，S集合是已计算出最短路径的顶点集合，PQ是未计算出最短路径的顶点的集合。 顶点附近的绿色数字表示从源节点到当前节点的距离，若二者没有直接相连，则为无穷大（∞）。 从PQ的所有顶点中，选择距离值最小的顶点放入集合S中。 首先将起始点s放入集合S中，然后将距离进行更新，可见图中2、6、7顶点的距离值发生了变化。 此时PQ集合中距离值最小的顶点是2号顶点。 此时将2号顶点放入集合S中，同时记录其父顶点为S。 然后将距离值进行更新。 此时PQ中6号顶点距离值最小。 将6号顶点加入集合S，同时，PQ中的5号和3号顶点距离值进行了更新。 此时，PQ中7号顶点的距离值最小。 7号顶点加入集合S，同时5号和t顶点距离值更新。 此时，PQ中3号顶点的距离值最小。 3号顶点加入集合S，同时5号和t顶点距离值更新。 此时，PQ中5号顶点的距离值最小。 5号顶点加入集合S，同时4号和t顶点距离值更新。 此时，PQ中4号顶点的距离值最小。 4号顶点加入集合S，此时t的距离值由于未减小，因此没有发生变化。 此时仅剩最后一个t顶点。 t顶点加入集合S。 实际上，我们可以得到起始点s到各个顶点的最短距离：2(9),3(32),4(45),5(34),6(14),7(15),t(50) 。 从起始点s到目标点t的最短路径为s-&amp;gt;6-&amp;gt;3-&amp;gt;5-&amp;gt;t。   总结一下算法流程： 初始化时，S只含有源节点s； 从PQ中选取一个距离s最小的顶点k加入S中（该选定的距离就是s到k的最短路径长度）； 以k为新考虑的中间点，修改PQ中各顶点的距离；若从源节点s到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值是顶点k的距离加上k到u的距离； 重复步骤2和3，直到所有顶点都包含在S中。 A*算法   同样地，我们结合实例来看一下A*算法是如何实现的。 绿色方格是我们的起始点，红色方格是我们的目标点，蓝色表示障碍物，我们需要寻找起始点到目标点的 路径。 首先，将图中的搜索区域用二维数组表示，数组的每一项代表一个格子，它的状态分为可走 (walkalbe)  和不可走 (unwalkable) 。 我们还需要初始化Open List和Close List，Open List用于存放路径规划过程中待检测的格子，而 Close List用于存放已检测过的格子。我们先将起始点A(1,2)放入Closed List，然后把相邻的可走的  方格加入到 Open List 中，然后把起点 A 设置为这些方格的父节点，方便路径追踪。 我们引入一个计算公式：F = G + H。其中G代表的是从起始节点沿着已生成的路径到指定待检测格子的 移动开销。H指待测格子到目标节点的估计移动开销，也称为启发项。假设横向或纵向移动的开销G是10， 沿对角线移动的开销是14，H是当前方格到目标方格的横向或纵向移动开销之和。 因为Open List中方格(2,2)的F值最小，因此将(2,2)加入Closed List并作为当前要处理的节点。 (2,2)的8个相邻方格中，有3个是障碍物，1个是在Close List中，忽略这几个方格。 剩下的4个方格都是在Open List中的方格，因此检查经由(2,2)到这4个方格的路径是否更好，用G来衡量， 比如原来从(1,2)到(2,3)的G为14，若从(1,2)先经过(2,2)再到(2,3)，则G变为20，显然还不如原来的路 径，对于其它3个方格亦是如此。 将(2,1)加入Close List，其相邻的8个方格中，2个障碍物的方格和障碍物下的方格(3,0)认为不可达， (1,2)和(2,2)在Close List中不做处理，Open List中的(1,1)没有优化原来的路径。 (1,0)和(2,0)加入Open List，并将父节点设置为(2,1)，分别计算F、G、H值。 以此类推，直到目标方格B加入Open List。 从目标方格B开始沿着父节点移动到起始方格A，就是求得的路径： (5,2)-&amp;gt;(5,1)-&amp;gt;(4,0)-&amp;gt;(3,0)-&amp;gt;(2,0)-&amp;gt;(2,1)-&amp;gt;(1,2)。 对比 Dijkstra 算法需要载入全部数据进行全局遍历，确保运算结果一定是最短路径。 A*算法的核心思想在于设置的代价函数F=H+G，来寻找距离start和goal代价距离和F最少的点。 参考资料 [1] https://blog.csdn.net/heroacool/article/details/51014824 [2] https://blog.csdn.net/weixin_44489823/article/details/89382502</summary></entry><entry><title type="html">2 机器人导航 move_base</title><link href="http://localhost:4000/2019/08/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%B9%8Bmove_base.html" rel="alternate" type="text/html" title="2 机器人导航 move_base" /><published>2019-08-28T00:00:00+08:00</published><updated>2019-08-28T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%B9%8Bmove_base</id><content type="html" xml:base="http://localhost:4000/2019/08/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%B9%8Bmove_base.html">&lt;h1 id=&quot;move_base&quot;&gt;move_base&lt;/h1&gt;

&lt;p&gt;  move_base节点位于导航框架正中心，可以理解为一个强大的路径规划器，在实际的导航任务中，只需要启动这一个node，并且给他提供数据，就可以规划出路径和速度。在navigation这个问题的角度，map是作为已知信息，默认是已经解决的。&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;框架.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;  下图表示了move_base的组成部分。&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;组成.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;  中间这个节点就是move_base，它要正常工作，首先需要设置好三个接口，分别叫做&lt;strong&gt;Base Local Planner&lt;/strong&gt;、&lt;strong&gt;Base Global Planner&lt;/strong&gt;、&lt;strong&gt;Recovery Behavior&lt;/strong&gt;， 在ROS里，实际的路径规划一般就是分为这么三部分。&lt;/p&gt;

&lt;p&gt;  &lt;strong&gt;Base Local Planner&lt;/strong&gt;是全局规划，负责轨迹的大方向，用来躲避静态障碍物。&lt;strong&gt;Base Global Planner&lt;/strong&gt;是局部路径规划，负责具体的运动细节，用来躲避移动中的障碍物，也就是动态避障。&lt;/p&gt;

&lt;p&gt;  做好了这两部分路径规划，机器人就可以正常的运动了，但有些时候，机器人也会陷入一些运动情况，比如碰撞到障碍物，那它就会有一些恢复动作，&lt;strong&gt;Recovery Behavior&lt;/strong&gt;就属于异常动作处理的方法。&lt;/p&gt;

&lt;p&gt;  针对这三个接口，每一个ROS都给我们提供了一些插件，供用户来选择。比如局部路径规划，ROS提供了两个插件，这每一个插件，都是不同算法的实现，dwa_local_planner就是base_local_planner的重写版本，对动态窗口的速度采样更好，其实就是不同的package，在navigation metapackage你都能找到这些package。&lt;/p&gt;

&lt;p&gt;  我们可以看出，move_base是navigation的逻辑核心，是核心节点，之所以称之为核心，是因为它在导航的任务中 处于支配地位，其他的一些package都是它的插件。&lt;/p&gt;

&lt;h2 id=&quot;base_local-_planner插件&quot;&gt;base_local _planner插件&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;base_local_planner实现了Trajectory Rollout和DWA两种局部规划算法&lt;/li&gt;
  &lt;li&gt;dwa_local_planner可以看作是base_local_planner的改进版&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;base_global-_planner插件&quot;&gt;base_global _planner插件&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;parrot_planner实现了较简单的全局规划算法&lt;/li&gt;
  &lt;li&gt;Navfn实现了Dijkstra和A*全局规划算法&lt;/li&gt;
  &lt;li&gt;global_planner可以看作navfn的改进版&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;recovery_behavior插件&quot;&gt;recovery_behavior插件&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;clear_costmap_recovery实现了清楚代价地图的恢复行为&lt;/li&gt;
  &lt;li&gt;rotate_recovery实现了旋转的恢复行为&lt;/li&gt;
  &lt;li&gt;move_slow_and_clear实现了缓慢移动的恢复行为&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  需要说明一下，这里插件的概念并不是我们抽象的描述，而是在ROS里catkin编译系统能够认出的，也就是说插件不需要提前链接到ROS的程序上，只需在运行时加载插件就可以调用其中的功能。&lt;/p&gt;

&lt;h2 id=&quot;nav_core&quot;&gt;nav_core&lt;/h2&gt;

&lt;p&gt;  nav_core这个package定义了这三个接口，其实就是定义了三个接口类，然后各自继承和实现了这些功能。&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;nav_core.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;BaseGlobalPlanner是全局导航的接口，规定一个功能函数makePlan，给定起始跟目标，输出路径(一系列pose)走过去；&lt;/li&gt;
  &lt;li&gt;BaseLocalPlanner规定了一个核心函数computeVelocityCommands，就是计算局部地图内的下一步控制指令(线速度，角速度)；&lt;/li&gt;
  &lt;li&gt;RecoveryBehavior，规定一个runBehavior，在小车卡住情况下执行运动恢复，回到正常的导航状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  在ROS navigation中，move_base提供的是框架，通过对nav_core中规定的planner与 recovery_behavior的基类的接口进行调用来实现。这样做可以将框架与具体的实现方法隔离开来。而具体采用的方法由pluginlib 根据不同参数导入，这样的实现方法使得navigation的可定制性大大增加。&lt;/p&gt;</content><author><name>Green</name></author><category term="navigation" /><summary type="html">move_base   move_base节点位于导航框架正中心，可以理解为一个强大的路径规划器，在实际的导航任务中，只需要启动这一个node，并且给他提供数据，就可以规划出路径和速度。在navigation这个问题的角度，map是作为已知信息，默认是已经解决的。   下图表示了move_base的组成部分。   中间这个节点就是move_base，它要正常工作，首先需要设置好三个接口，分别叫做Base Local Planner、Base Global Planner、Recovery Behavior， 在ROS里，实际的路径规划一般就是分为这么三部分。   Base Local Planner是全局规划，负责轨迹的大方向，用来躲避静态障碍物。Base Global Planner是局部路径规划，负责具体的运动细节，用来躲避移动中的障碍物，也就是动态避障。   做好了这两部分路径规划，机器人就可以正常的运动了，但有些时候，机器人也会陷入一些运动情况，比如碰撞到障碍物，那它就会有一些恢复动作，Recovery Behavior就属于异常动作处理的方法。   针对这三个接口，每一个ROS都给我们提供了一些插件，供用户来选择。比如局部路径规划，ROS提供了两个插件，这每一个插件，都是不同算法的实现，dwa_local_planner就是base_local_planner的重写版本，对动态窗口的速度采样更好，其实就是不同的package，在navigation metapackage你都能找到这些package。   我们可以看出，move_base是navigation的逻辑核心，是核心节点，之所以称之为核心，是因为它在导航的任务中 处于支配地位，其他的一些package都是它的插件。 base_local _planner插件 base_local_planner实现了Trajectory Rollout和DWA两种局部规划算法 dwa_local_planner可以看作是base_local_planner的改进版 base_global _planner插件 parrot_planner实现了较简单的全局规划算法 Navfn实现了Dijkstra和A*全局规划算法 global_planner可以看作navfn的改进版 recovery_behavior插件 clear_costmap_recovery实现了清楚代价地图的恢复行为 rotate_recovery实现了旋转的恢复行为 move_slow_and_clear实现了缓慢移动的恢复行为   需要说明一下，这里插件的概念并不是我们抽象的描述，而是在ROS里catkin编译系统能够认出的，也就是说插件不需要提前链接到ROS的程序上，只需在运行时加载插件就可以调用其中的功能。 nav_core   nav_core这个package定义了这三个接口，其实就是定义了三个接口类，然后各自继承和实现了这些功能。 BaseGlobalPlanner是全局导航的接口，规定一个功能函数makePlan，给定起始跟目标，输出路径(一系列pose)走过去； BaseLocalPlanner规定了一个核心函数computeVelocityCommands，就是计算局部地图内的下一步控制指令(线速度，角速度)； RecoveryBehavior，规定一个runBehavior，在小车卡住情况下执行运动恢复，回到正常的导航状态。   在ROS navigation中，move_base提供的是框架，通过对nav_core中规定的planner与 recovery_behavior的基类的接口进行调用来实现。这样做可以将框架与具体的实现方法隔离开来。而具体采用的方法由pluginlib 根据不同参数导入，这样的实现方法使得navigation的可定制性大大增加。</summary></entry><entry><title type="html">1 机器人导航 简介</title><link href="http://localhost:4000/2019/08/20/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%BB%8B%E7%BB%8D.html" rel="alternate" type="text/html" title="1 机器人导航 简介" /><published>2019-08-20T00:00:00+08:00</published><updated>2019-08-20T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/20/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%BB%8B%E7%BB%8D</id><content type="html" xml:base="http://localhost:4000/2019/08/20/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%BB%8B%E7%BB%8D.html">&lt;h1 id=&quot;机器人导航简介&quot;&gt;机器人导航简介&lt;/h1&gt;

&lt;p&gt;  导航可以说是机器人最基本的功能之一，简单来说，导航就是机器人基于地图，实现从起始点前进到目标点的过程，这个过程中要求不发生碰撞并满足自身动力学模型（如不超过速度、加速度等限制）。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;什么是导航.png&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  将导航的任务进行细分，首先机器人在未知环境中需要使用激光传感器（或者是深度传感器）进行&lt;strong&gt;地图&lt;/strong&gt;构建，然后根据构建的地图进行&lt;strong&gt;定位&lt;/strong&gt;，有了地图和定位的基础，就可以根据目标点以及&lt;strong&gt;感知&lt;/strong&gt;的障碍物信息进行&lt;strong&gt;路径规划&lt;/strong&gt;了。我们可以将导航的要素归纳如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;地图&lt;/li&gt;
  &lt;li&gt;定位&lt;/li&gt;
  &lt;li&gt;感知&lt;/li&gt;
  &lt;li&gt;路径规划。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;导航元素.png&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;地图&quot;&gt;地图&lt;/h2&gt;

&lt;p&gt;  下面这张图是ROS中的一个地图，其实也就是一张普通的灰度图像。图像上的黑色像素表示障碍物，白色像素表示可行区域，灰色是未探索的区域。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;地图示例.png&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  一般来说，地图是通过&lt;a href=&quot;https://baike.baidu.com/item/SLAM/7661974?fr=aladdin&quot;&gt;SLAM&lt;/a&gt;(同时定位与建图)来构建的，这里就不展开了。&lt;/p&gt;

&lt;h2 id=&quot;定位&quot;&gt;定位&lt;/h2&gt;

&lt;p&gt;  定位是对机器人位置和姿态（一般简称位姿）的测量或估计，简单来说，通过定位，机器人可以知道自己在哪儿以及所面朝的方向。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;定位.png&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;感知&quot;&gt;感知&lt;/h2&gt;

&lt;p&gt;  机器人是通过传感器来感知周围环境的。下面三个图是机器人常用的传感器，从左至右分别是超声波传感器，激光雷达，深度摄像头（与传统的摄像头区别在于加入了深度信息，可以测量像素点距离摄像头的距离）。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;传感器.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  通过这些传感器的数据，就可以对墙壁、路障等障碍物进行感知识别。&lt;/p&gt;

&lt;h1 id=&quot;ros导航框架&quot;&gt;ROS导航框架&lt;/h1&gt;

&lt;p&gt;  这是&lt;a href=&quot;http://wiki.ros.org/move_base&quot;&gt;ROS wiki&lt;/a&gt;上的一张图，介绍了ROS导航的整体工作框架：&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;导航框架.png&quot; width=&quot;90%&quot; height=&quot;90%&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;  白色是已经提供给你的节点，灰色是可选的，蓝色是根据平台的差异而不同的节点。&lt;/p&gt;

&lt;p&gt;  首先，navigation框架里面的核心是中间的&lt;strong&gt;move_base&lt;/strong&gt;，这是导航最重要的一个package，它负责运动规划，这里面有&lt;strong&gt;global planner&lt;/strong&gt;和&lt;strong&gt;local planner&lt;/strong&gt;，把路径规划问题分解为全局和局部两部分来解决，而这两个planner做出决策，要参考全局和局部的&lt;strong&gt;costmap&lt;/strong&gt;代价地图。然后move_base还包括了一些&lt;strong&gt;recovery behaviors&lt;/strong&gt;，让机器人在某些情况下，比如说碰到障碍物，卡住，会采取一些恢复措施。&lt;/p&gt;

&lt;p&gt;  我们先把move_base看成一个整体进行一定程度的简化，如下图所示。可以认为move_base就是一个路径规划的工具，然后分析move_base需要什么输入，然后它能输出给我们什么数据。&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;简化导航框架.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;  有这么几个数据是必须给的，一个是TransForms(tf)，路径规划当然得知道各个坐标系的变换关系了，尤其是当前机器人在地图的什么位置。那其中必不可少的是map-&amp;gt;odom-&amp;gt;base之间的tf，还有base到其他各个机器人零部件的tf。&lt;/p&gt;

&lt;p&gt;  还有就是Odemetry(odem)的数据，刚才tf只提供了位置和方向信息，但是实际路径规划，还要考虑速度和角速度，所以这里专门有一个odom来提供位置方向、线速度、角速度。这个odom注意，是一个topic，不是tf里的odom frame。类似的还有map，既是tf里的frame，也是一个topic。&lt;/p&gt;

&lt;p&gt;  除了odom之外，还有一个Laser，可以是激光雷达，可以是深度摄像头的点云，主要是用来帮助构建costmap，实现避障。&lt;/p&gt;

&lt;p&gt;  所以你需要提供的数据，通常来说就是这么几个，/map，/tf， /scan， /odom，以及目标点的信息。&lt;/p&gt;

&lt;p&gt;  那navigation 输出什么呢？很简单，输出的就是路径规划算出来的当前速度，/cmd_vel。&lt;/p&gt;

&lt;h2 id=&quot;navigation-stack&quot;&gt;Navigation Stack&lt;/h2&gt;

&lt;p&gt;Navigation Stack是一个ROS的功能包集，里面包含了ROS在路径规划、定位、地图、异常行为恢复等方面的package，如下表所示。这么多package，你可能会觉得很乱，不过不用担心，在使用中其实还是比较简单的。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;包名&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;amcl&lt;/td&gt;
      &lt;td&gt;定位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Fake_localization&lt;/td&gt;
      &lt;td&gt;定位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;map_server&lt;/td&gt;
      &lt;td&gt;提供地图&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;move_base&lt;/td&gt;
      &lt;td&gt;路径规划节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;nav_core&lt;/td&gt;
      &lt;td&gt;路径规划接口类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;base_local _planner&lt;/td&gt;
      &lt;td&gt;实现了Trajectory Rollout和DWA两种局部规划算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dwa_local _planner&lt;/td&gt;
      &lt;td&gt;重新实现了DWA局部规划算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;parrot_planner&lt;/td&gt;
      &lt;td&gt;实现了较简单的全局规划算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;navfn&lt;/td&gt;
      &lt;td&gt;实现了Dijkstra和A*全局规划算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;global_planner&lt;/td&gt;
      &lt;td&gt;重新实现了Dijkstra和A*全局规划算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;clear_costmap _recovery&lt;/td&gt;
      &lt;td&gt;实现了清除代价地图的恢复行为&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rotate_recovery&lt;/td&gt;
      &lt;td&gt;实现了旋转的恢复行为&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;move_slow _ and_clear&lt;/td&gt;
      &lt;td&gt;路径规划接口类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;costmap_2d&lt;/td&gt;
      &lt;td&gt;二维代价地图&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;voxel_grid&lt;/td&gt;
      &lt;td&gt;三维小方块&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;robot_pose _ekf&lt;/td&gt;
      &lt;td&gt;机器人位姿的卡尔曼滤波&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;[1] http://wiki.ros.org/move_base&lt;/p&gt;

&lt;p&gt;[2] http://wiki.ros.org/navigation&lt;/p&gt;</content><author><name>Green</name></author><category term="navigation" /><summary type="html">机器人导航简介   导航可以说是机器人最基本的功能之一，简单来说，导航就是机器人基于地图，实现从起始点前进到目标点的过程，这个过程中要求不发生碰撞并满足自身动力学模型（如不超过速度、加速度等限制）。   将导航的任务进行细分，首先机器人在未知环境中需要使用激光传感器（或者是深度传感器）进行地图构建，然后根据构建的地图进行定位，有了地图和定位的基础，就可以根据目标点以及感知的障碍物信息进行路径规划了。我们可以将导航的要素归纳如下： 地图 定位 感知 路径规划。 地图   下面这张图是ROS中的一个地图，其实也就是一张普通的灰度图像。图像上的黑色像素表示障碍物，白色像素表示可行区域，灰色是未探索的区域。   一般来说，地图是通过SLAM(同时定位与建图)来构建的，这里就不展开了。 定位   定位是对机器人位置和姿态（一般简称位姿）的测量或估计，简单来说，通过定位，机器人可以知道自己在哪儿以及所面朝的方向。 感知   机器人是通过传感器来感知周围环境的。下面三个图是机器人常用的传感器，从左至右分别是超声波传感器，激光雷达，深度摄像头（与传统的摄像头区别在于加入了深度信息，可以测量像素点距离摄像头的距离）。   通过这些传感器的数据，就可以对墙壁、路障等障碍物进行感知识别。 ROS导航框架   这是ROS wiki上的一张图，介绍了ROS导航的整体工作框架：   白色是已经提供给你的节点，灰色是可选的，蓝色是根据平台的差异而不同的节点。   首先，navigation框架里面的核心是中间的move_base，这是导航最重要的一个package，它负责运动规划，这里面有global planner和local planner，把路径规划问题分解为全局和局部两部分来解决，而这两个planner做出决策，要参考全局和局部的costmap代价地图。然后move_base还包括了一些recovery behaviors，让机器人在某些情况下，比如说碰到障碍物，卡住，会采取一些恢复措施。   我们先把move_base看成一个整体进行一定程度的简化，如下图所示。可以认为move_base就是一个路径规划的工具，然后分析move_base需要什么输入，然后它能输出给我们什么数据。   有这么几个数据是必须给的，一个是TransForms(tf)，路径规划当然得知道各个坐标系的变换关系了，尤其是当前机器人在地图的什么位置。那其中必不可少的是map-&amp;gt;odom-&amp;gt;base之间的tf，还有base到其他各个机器人零部件的tf。   还有就是Odemetry(odem)的数据，刚才tf只提供了位置和方向信息，但是实际路径规划，还要考虑速度和角速度，所以这里专门有一个odom来提供位置方向、线速度、角速度。这个odom注意，是一个topic，不是tf里的odom frame。类似的还有map，既是tf里的frame，也是一个topic。   除了odom之外，还有一个Laser，可以是激光雷达，可以是深度摄像头的点云，主要是用来帮助构建costmap，实现避障。   所以你需要提供的数据，通常来说就是这么几个，/map，/tf， /scan， /odom，以及目标点的信息。   那navigation 输出什么呢？很简单，输出的就是路径规划算出来的当前速度，/cmd_vel。 Navigation Stack Navigation Stack是一个ROS的功能包集，里面包含了ROS在路径规划、定位、地图、异常行为恢复等方面的package，如下表所示。这么多package，你可能会觉得很乱，不过不用担心，在使用中其实还是比较简单的。 包名 功能 amcl 定位 Fake_localization 定位 map_server 提供地图 move_base 路径规划节点 nav_core 路径规划接口类 base_local _planner 实现了Trajectory Rollout和DWA两种局部规划算法 dwa_local _planner 重新实现了DWA局部规划算法 parrot_planner 实现了较简单的全局规划算法 navfn 实现了Dijkstra和A*全局规划算法 global_planner 重新实现了Dijkstra和A*全局规划算法 clear_costmap _recovery 实现了清除代价地图的恢复行为 rotate_recovery 实现了旋转的恢复行为 move_slow _ and_clear 路径规划接口类 costmap_2d 二维代价地图 voxel_grid 三维小方块 robot_pose _ekf 机器人位姿的卡尔曼滤波 参考资料 [1] http://wiki.ros.org/move_base [2] http://wiki.ros.org/navigation</summary></entry></feed>