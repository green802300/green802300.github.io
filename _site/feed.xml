<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-08-28T17:12:26+08:00</updated><id>http://localhost:4000/</id><title type="html">Green’s HomePage</title><subtitle>这是一个初学博客的博主</subtitle><author><name>true</name></author><entry><title type="html">2 机器人导航 move_base</title><link href="http://localhost:4000/2019/08/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%B9%8Bmove_base.html" rel="alternate" type="text/html" title="2 机器人导航 move_base" /><published>2019-08-28T00:00:00+08:00</published><updated>2019-08-28T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%B9%8Bmove_base</id><content type="html" xml:base="http://localhost:4000/2019/08/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%B9%8Bmove_base.html">&lt;h1 id=&quot;move_base&quot;&gt;move_base&lt;/h1&gt;

&lt;p&gt;  move_base节点位于导航框架正中心，可以理解为一个强大的路径规划器，在实际的导航任务中，只需要启动这一个node，并且给他提供数据，就可以规划出路径和速度。在navigation这个问题的角度，map是作为已知信息，默认是已经解决的。&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;框架.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;  下图表示了move_base的组成部分。&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;组成.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;  中间这个节点就是move_base，它要正常工作，首先需要设置好三个接口，分别叫做&lt;strong&gt;Base Local Planner&lt;/strong&gt;、&lt;strong&gt;Base Global Planner&lt;/strong&gt;、&lt;strong&gt;Recovery Behavior&lt;/strong&gt;， 在ROS里，实际的路径规划一般就是分为这么三部分。&lt;/p&gt;

&lt;p&gt;  &lt;strong&gt;Base Local Planner&lt;/strong&gt;是全局规划，负责轨迹的大方向，用来躲避静态障碍物。&lt;strong&gt;Base Global Planner&lt;/strong&gt;是局部路径规划，负责具体的运动细节，用来躲避移动中的障碍物，也就是动态避障。&lt;/p&gt;

&lt;p&gt;  做好了这两部分路径规划，机器人就可以正常的运动了，但有些时候，机器人也会陷入一些运动情况，比如碰撞到障碍物，那它就会有一些恢复动作，&lt;strong&gt;Recovery Behavior&lt;/strong&gt;就属于异常动作处理的方法。&lt;/p&gt;

&lt;p&gt;  针对这三个接口，每一个ROS都给我们提供了一些插件，供用户来选择。比如局部路径规划，ROS提供了两个插件，这每一个插件，都是不同算法的实现，dwa_local_planner就是base_local_planner的重写版本，对动态窗口的速度采样更好，其实就是不同的package，在navigation metapackage你都能找到这些package。&lt;/p&gt;

&lt;p&gt;  我们可以看出，move_base是navigation的逻辑核心，是核心节点，之所以称之为核心，是因为它在导航的任务中 处于支配地位，其他的一些package都是它的插件。&lt;/p&gt;

&lt;h2 id=&quot;base_local-_planner插件&quot;&gt;base_local _planner插件&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;base_local_planner实现了Trajectory Rollout和DWA两种局部规划算法&lt;/li&gt;
  &lt;li&gt;dwa_local_planner可以看作是base_local_planner的改进版&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;base_global-_planner插件&quot;&gt;base_global _planner插件&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;parrot_planner实现了较简单的全局规划算法&lt;/li&gt;
  &lt;li&gt;Navfn实现了Dijkstra和A*全局规划算法&lt;/li&gt;
  &lt;li&gt;global_planner可以看作navfn的改进版&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;recovery_behavior插件&quot;&gt;recovery_behavior插件&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;clear_costmap_recovery实现了清楚代价地图的恢复行为&lt;/li&gt;
  &lt;li&gt;rotate_recovery实现了旋转的恢复行为&lt;/li&gt;
  &lt;li&gt;move_slow_and_clear实现了缓慢移动的恢复行为&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  需要说明一下，这里插件的概念并不是我们抽象的描述，而是在ROS里catkin编译系统能够认出的，也就是说插件不需要提前链接到ROS的程序上，只需在运行时加载插件就可以调用其中的功能。&lt;/p&gt;

&lt;h2 id=&quot;nav_core&quot;&gt;nav_core&lt;/h2&gt;

&lt;p&gt;  nav_core这个package定义了这三个接口，其实就是定义了三个接口类，然后各自继承和实现了这些功能。&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;nav_core.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;BaseGlobalPlanner是全局导航的接口，规定一个功能函数makePlan，给定起始跟目标，输出路径(一系列pose)走过去；&lt;/li&gt;
  &lt;li&gt;BaseLocalPlanner规定了一个核心函数computeVelocityCommands，就是计算局部地图内的下一步控制指令(线速度，角速度)；&lt;/li&gt;
  &lt;li&gt;RecoveryBehavior，规定一个runBehavior，在小车卡住情况下执行运动恢复，回到正常的导航状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  在ROS navigation中，move_base提供的是框架，通过对nav_core中规定的planner与 recovery_behavior的基类的接口进行调用来实现。这样做可以将框架与具体的实现方法隔离开来。而具体采用的方法由pluginlib 根据不同参数导入，这样的实现方法使得navigation的可定制性大大增加。&lt;/p&gt;</content><author><name>Green</name></author><category term="navigation" /><summary type="html">move_base   move_base节点位于导航框架正中心，可以理解为一个强大的路径规划器，在实际的导航任务中，只需要启动这一个node，并且给他提供数据，就可以规划出路径和速度。在navigation这个问题的角度，map是作为已知信息，默认是已经解决的。   下图表示了move_base的组成部分。   中间这个节点就是move_base，它要正常工作，首先需要设置好三个接口，分别叫做Base Local Planner、Base Global Planner、Recovery Behavior， 在ROS里，实际的路径规划一般就是分为这么三部分。   Base Local Planner是全局规划，负责轨迹的大方向，用来躲避静态障碍物。Base Global Planner是局部路径规划，负责具体的运动细节，用来躲避移动中的障碍物，也就是动态避障。   做好了这两部分路径规划，机器人就可以正常的运动了，但有些时候，机器人也会陷入一些运动情况，比如碰撞到障碍物，那它就会有一些恢复动作，Recovery Behavior就属于异常动作处理的方法。   针对这三个接口，每一个ROS都给我们提供了一些插件，供用户来选择。比如局部路径规划，ROS提供了两个插件，这每一个插件，都是不同算法的实现，dwa_local_planner就是base_local_planner的重写版本，对动态窗口的速度采样更好，其实就是不同的package，在navigation metapackage你都能找到这些package。   我们可以看出，move_base是navigation的逻辑核心，是核心节点，之所以称之为核心，是因为它在导航的任务中 处于支配地位，其他的一些package都是它的插件。 base_local _planner插件 base_local_planner实现了Trajectory Rollout和DWA两种局部规划算法 dwa_local_planner可以看作是base_local_planner的改进版 base_global _planner插件 parrot_planner实现了较简单的全局规划算法 Navfn实现了Dijkstra和A*全局规划算法 global_planner可以看作navfn的改进版 recovery_behavior插件 clear_costmap_recovery实现了清楚代价地图的恢复行为 rotate_recovery实现了旋转的恢复行为 move_slow_and_clear实现了缓慢移动的恢复行为   需要说明一下，这里插件的概念并不是我们抽象的描述，而是在ROS里catkin编译系统能够认出的，也就是说插件不需要提前链接到ROS的程序上，只需在运行时加载插件就可以调用其中的功能。 nav_core   nav_core这个package定义了这三个接口，其实就是定义了三个接口类，然后各自继承和实现了这些功能。 BaseGlobalPlanner是全局导航的接口，规定一个功能函数makePlan，给定起始跟目标，输出路径(一系列pose)走过去； BaseLocalPlanner规定了一个核心函数computeVelocityCommands，就是计算局部地图内的下一步控制指令(线速度，角速度)； RecoveryBehavior，规定一个runBehavior，在小车卡住情况下执行运动恢复，回到正常的导航状态。   在ROS navigation中，move_base提供的是框架，通过对nav_core中规定的planner与 recovery_behavior的基类的接口进行调用来实现。这样做可以将框架与具体的实现方法隔离开来。而具体采用的方法由pluginlib 根据不同参数导入，这样的实现方法使得navigation的可定制性大大增加。</summary></entry><entry><title type="html">1 机器人导航 简介</title><link href="http://localhost:4000/2019/08/20/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%BB%8B%E7%BB%8D.html" rel="alternate" type="text/html" title="1 机器人导航 简介" /><published>2019-08-20T00:00:00+08:00</published><updated>2019-08-20T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/20/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%BB%8B%E7%BB%8D</id><content type="html" xml:base="http://localhost:4000/2019/08/20/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%E4%BB%8B%E7%BB%8D.html">&lt;h1 id=&quot;机器人导航简介&quot;&gt;机器人导航简介&lt;/h1&gt;

&lt;p&gt;  导航可以说是机器人最基本的功能之一，简单来说，导航就是机器人基于地图，实现从起始点前进到目标点的过程，这个过程中要求不发生碰撞并满足自身动力学模型（如不超过速度、加速度等限制）。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;什么是导航.png&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  将导航的任务进行细分，首先机器人在未知环境中需要使用激光传感器（或者是深度传感器）进行&lt;strong&gt;地图&lt;/strong&gt;构建，然后根据构建的地图进行&lt;strong&gt;定位&lt;/strong&gt;，有了地图和定位的基础，就可以根据目标点以及&lt;strong&gt;感知&lt;/strong&gt;的障碍物信息进行&lt;strong&gt;路径规划&lt;/strong&gt;了。我们可以将导航的要素归纳如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;地图&lt;/li&gt;
  &lt;li&gt;定位&lt;/li&gt;
  &lt;li&gt;感知&lt;/li&gt;
  &lt;li&gt;路径规划。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;导航元素.png&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;地图&quot;&gt;地图&lt;/h2&gt;

&lt;p&gt;  下面这张图是ROS中的一个地图，其实也就是一张普通的灰度图像。图像上的黑色像素表示障碍物，白色像素表示可行区域，灰色是未探索的区域。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;地图示例.png&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  一般来说，地图是通过&lt;a href=&quot;https://baike.baidu.com/item/SLAM/7661974?fr=aladdin&quot;&gt;SLAM&lt;/a&gt;(同时定位与建图)来构建的，这里就不展开了。&lt;/p&gt;

&lt;h2 id=&quot;定位&quot;&gt;定位&lt;/h2&gt;

&lt;p&gt;  定位是对机器人位置和姿态（一般简称位姿）的测量或估计，简单来说，通过定位，机器人可以知道自己在哪儿以及所面朝的方向。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;定位.png&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;感知&quot;&gt;感知&lt;/h2&gt;

&lt;p&gt;  机器人是通过传感器来感知周围环境的。下面三个图是机器人常用的传感器，从左至右分别是超声波传感器，激光雷达，深度摄像头（与传统的摄像头区别在于加入了深度信息，可以测量像素点距离摄像头的距离）。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;传感器.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  通过这些传感器的数据，就可以对墙壁、路障等障碍物进行感知识别。&lt;/p&gt;

&lt;h1 id=&quot;ros导航框架&quot;&gt;ROS导航框架&lt;/h1&gt;

&lt;p&gt;  这是&lt;a href=&quot;http://wiki.ros.org/move_base&quot;&gt;ROS wiki&lt;/a&gt;上的一张图，介绍了ROS导航的整体工作框架：&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;导航框架.png&quot; width=&quot;90%&quot; height=&quot;90%&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;  白色是已经提供给你的节点，灰色是可选的，蓝色是根据平台的差异而不同的节点。&lt;/p&gt;

&lt;p&gt;  首先，navigation框架里面的核心是中间的&lt;strong&gt;move_base&lt;/strong&gt;，这是导航最重要的一个package，它负责运动规划，这里面有&lt;strong&gt;global planner&lt;/strong&gt;和&lt;strong&gt;local planner&lt;/strong&gt;，把路径规划问题分解为全局和局部两部分来解决，而这两个planner做出决策，要参考全局和局部的&lt;strong&gt;costmap&lt;/strong&gt;代价地图。然后move_base还包括了一些&lt;strong&gt;recovery behaviors&lt;/strong&gt;，让机器人在某些情况下，比如说碰到障碍物，卡住，会采取一些恢复措施。&lt;/p&gt;

&lt;p&gt;  我们先把move_base看成一个整体进行一定程度的简化，如下图所示。可以认为move_base就是一个路径规划的工具，然后分析move_base需要什么输入，然后它能输出给我们什么数据。&lt;/p&gt;

&lt;figure align=&quot;center&quot;&gt;
  &lt;img src=&quot;简化导航框架.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;  有这么几个数据是必须给的，一个是TransForms(tf)，路径规划当然得知道各个坐标系的变换关系了，尤其是当前机器人在地图的什么位置。那其中必不可少的是map-&amp;gt;odom-&amp;gt;base之间的tf，还有base到其他各个机器人零部件的tf。&lt;/p&gt;

&lt;p&gt;  还有就是Odemetry(odem)的数据，刚才tf只提供了位置和方向信息，但是实际路径规划，还要考虑速度和角速度，所以这里专门有一个odom来提供位置方向、线速度、角速度。这个odom注意，是一个topic，不是tf里的odom frame。类似的还有map，既是tf里的frame，也是一个topic。&lt;/p&gt;

&lt;p&gt;  除了odom之外，还有一个Laser，可以是激光雷达，可以是深度摄像头的点云，主要是用来帮助构建costmap，实现避障。&lt;/p&gt;

&lt;p&gt;  所以你需要提供的数据，通常来说就是这么几个，/map，/tf， /scan， /odom，以及目标点的信息。&lt;/p&gt;

&lt;p&gt;  那navigation 输出什么呢？很简单，输出的就是路径规划算出来的当前速度，/cmd_vel。&lt;/p&gt;

&lt;h2 id=&quot;navigation-stack&quot;&gt;Navigation Stack&lt;/h2&gt;

&lt;p&gt;Navigation Stack是一个ROS的功能包集，里面包含了ROS在路径规划、定位、地图、异常行为恢复等方面的package，如下表所示。这么多package，你可能会觉得很乱，不过不用担心，在使用中其实还是比较简单的。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;包名&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;amcl&lt;/td&gt;
      &lt;td&gt;定位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Fake_localization&lt;/td&gt;
      &lt;td&gt;定位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;map_server&lt;/td&gt;
      &lt;td&gt;提供地图&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;move_base&lt;/td&gt;
      &lt;td&gt;路径规划节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;nav_core&lt;/td&gt;
      &lt;td&gt;路径规划接口类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;base_local _planner&lt;/td&gt;
      &lt;td&gt;实现了Trajectory Rollout和DWA两种局部规划算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dwa_local _planner&lt;/td&gt;
      &lt;td&gt;重新实现了DWA局部规划算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;parrot_planner&lt;/td&gt;
      &lt;td&gt;实现了较简单的全局规划算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;navfn&lt;/td&gt;
      &lt;td&gt;实现了Dijkstra和A*全局规划算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;global_planner&lt;/td&gt;
      &lt;td&gt;重新实现了Dijkstra和A*全局规划算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;clear_costmap _recovery&lt;/td&gt;
      &lt;td&gt;实现了清除代价地图的恢复行为&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rotate_recovery&lt;/td&gt;
      &lt;td&gt;实现了旋转的恢复行为&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;move_slow _ and_clear&lt;/td&gt;
      &lt;td&gt;路径规划接口类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;costmap_2d&lt;/td&gt;
      &lt;td&gt;二维代价地图&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;voxel_grid&lt;/td&gt;
      &lt;td&gt;三维小方块&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;robot_pose _ekf&lt;/td&gt;
      &lt;td&gt;机器人位姿的卡尔曼滤波&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;[1] http://wiki.ros.org/move_base&lt;/p&gt;

&lt;p&gt;[2] http://wiki.ros.org/navigation&lt;/p&gt;</content><author><name>Green</name></author><category term="navigation" /><summary type="html">机器人导航简介   导航可以说是机器人最基本的功能之一，简单来说，导航就是机器人基于地图，实现从起始点前进到目标点的过程，这个过程中要求不发生碰撞并满足自身动力学模型（如不超过速度、加速度等限制）。   将导航的任务进行细分，首先机器人在未知环境中需要使用激光传感器（或者是深度传感器）进行地图构建，然后根据构建的地图进行定位，有了地图和定位的基础，就可以根据目标点以及感知的障碍物信息进行路径规划了。我们可以将导航的要素归纳如下： 地图 定位 感知 路径规划。 地图   下面这张图是ROS中的一个地图，其实也就是一张普通的灰度图像。图像上的黑色像素表示障碍物，白色像素表示可行区域，灰色是未探索的区域。   一般来说，地图是通过SLAM(同时定位与建图)来构建的，这里就不展开了。 定位   定位是对机器人位置和姿态（一般简称位姿）的测量或估计，简单来说，通过定位，机器人可以知道自己在哪儿以及所面朝的方向。 感知   机器人是通过传感器来感知周围环境的。下面三个图是机器人常用的传感器，从左至右分别是超声波传感器，激光雷达，深度摄像头（与传统的摄像头区别在于加入了深度信息，可以测量像素点距离摄像头的距离）。   通过这些传感器的数据，就可以对墙壁、路障等障碍物进行感知识别。 ROS导航框架   这是ROS wiki上的一张图，介绍了ROS导航的整体工作框架：   白色是已经提供给你的节点，灰色是可选的，蓝色是根据平台的差异而不同的节点。   首先，navigation框架里面的核心是中间的move_base，这是导航最重要的一个package，它负责运动规划，这里面有global planner和local planner，把路径规划问题分解为全局和局部两部分来解决，而这两个planner做出决策，要参考全局和局部的costmap代价地图。然后move_base还包括了一些recovery behaviors，让机器人在某些情况下，比如说碰到障碍物，卡住，会采取一些恢复措施。   我们先把move_base看成一个整体进行一定程度的简化，如下图所示。可以认为move_base就是一个路径规划的工具，然后分析move_base需要什么输入，然后它能输出给我们什么数据。   有这么几个数据是必须给的，一个是TransForms(tf)，路径规划当然得知道各个坐标系的变换关系了，尤其是当前机器人在地图的什么位置。那其中必不可少的是map-&amp;gt;odom-&amp;gt;base之间的tf，还有base到其他各个机器人零部件的tf。   还有就是Odemetry(odem)的数据，刚才tf只提供了位置和方向信息，但是实际路径规划，还要考虑速度和角速度，所以这里专门有一个odom来提供位置方向、线速度、角速度。这个odom注意，是一个topic，不是tf里的odom frame。类似的还有map，既是tf里的frame，也是一个topic。   除了odom之外，还有一个Laser，可以是激光雷达，可以是深度摄像头的点云，主要是用来帮助构建costmap，实现避障。   所以你需要提供的数据，通常来说就是这么几个，/map，/tf， /scan， /odom，以及目标点的信息。   那navigation 输出什么呢？很简单，输出的就是路径规划算出来的当前速度，/cmd_vel。 Navigation Stack Navigation Stack是一个ROS的功能包集，里面包含了ROS在路径规划、定位、地图、异常行为恢复等方面的package，如下表所示。这么多package，你可能会觉得很乱，不过不用担心，在使用中其实还是比较简单的。 包名 功能 amcl 定位 Fake_localization 定位 map_server 提供地图 move_base 路径规划节点 nav_core 路径规划接口类 base_local _planner 实现了Trajectory Rollout和DWA两种局部规划算法 dwa_local _planner 重新实现了DWA局部规划算法 parrot_planner 实现了较简单的全局规划算法 navfn 实现了Dijkstra和A*全局规划算法 global_planner 重新实现了Dijkstra和A*全局规划算法 clear_costmap _recovery 实现了清除代价地图的恢复行为 rotate_recovery 实现了旋转的恢复行为 move_slow _ and_clear 路径规划接口类 costmap_2d 二维代价地图 voxel_grid 三维小方块 robot_pose _ekf 机器人位姿的卡尔曼滤波 参考资料 [1] http://wiki.ros.org/move_base [2] http://wiki.ros.org/navigation</summary></entry></feed>